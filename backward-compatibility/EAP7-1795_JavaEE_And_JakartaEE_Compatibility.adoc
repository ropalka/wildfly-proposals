= [EAP7-1795] EAP6 and EAP7 applications have to communicate with EAP8 apps successfully and vice versa
:author:            Richard Opalka; Flavia Rainone
:email:             ropalka@redhat.com; frainone@@redhat.com
:toc:               left
:icons:             font
:idprefix:
:idseparator:       -

== Overview

This feature will ensure bidirectional EJB, JNDI & HTTP remote protocols backward
compatibility between Java EE 8- and Jakarta EE 9+ WildFly/EAP versions.

== Issue Metadata

=== Issue:

* https://issues.redhat.com/browse/EAP7-1795[EAP7-1795]

=== Related Issues:

* https://issues.redhat.com/browse/EAP7-1453[EAP7-1453]
* https://issues.redhat.com/browse/EAP7-1960[EAP7-1960]

=== Dev Contacts:
* mailto:ropalka@redhat.com[Richard Opalka]
* mailto:frainone@redhat.com[Flavia Rainone]

=== QE Contacts:
TODO

=== Testing By
* [ ] Engineering

* [x] QE

=== Affected Projects or Components:

* JBoss Marshalling, JBoss EJB Client, WildFly Naming Client, WildFly Http Client

=== Relevant Installation Types
* [x] Traditional standalone server (unzipped or provisioned by Galleon)

* [x] Managed domain

* [x] OpenShift s2i

* [x] Bootable jar

== Requirements

=== Hard requirements

* Ability of Java EE 8- client/server to communicate with Jakarta EE 9+ server/client via EJB, JNDI and HTTP remote protocols.
* Ability of Jakarta EE 9+ client/server to communicate with Java EE 8- server/client via EJB, JNDI and HTTP remote protocols.
* Java EE 8- WildFly/EAP versions cannot be modified in order to be able to communicate with Jakarta EE9+ WildFly/EAP variants.
* Backward compatibility mode is off by default, and can be enabled by setting the `org.wildfly.ee.namespace.interop` system
property to `true`.
* If the property is set to `true` on a Java EE 8- server/client, it is ignored, as those clients and servers are not
responsible for handling interoperability.


=== None requirements

* Infinispan and Clustering protocols backward compatibility.
* ABI compatibility for non existing mapping of classes/methods available in Java EE 8- but not in Jakarta EE 9+ and vice versa.
  Users will need to migrate their clients/applications for such problematic scenarios manually.

== Test Plan

The test will be created for hard requirements scenarios. This test will reside in QE's testsuite and will become
one of the must-execute tests for ensuring backward compatibility between EAP8+ and EAP7- variants.

== Community Documentation

Community documentation will be provided for how the aforementioned compatibility among remote EE clients and servers.
It will be added to the WildFly documentation, and it will be based on this analysis document as reference.

Also, the wildfly-http-client project documentation must also be updated describing the changes applied to the WildFly
HTTP Client protocol.

== Release Note Content
Bullet point: support interoperability between Jakarta EE 9 servers and Java EE 8 or older servers

== Design Notes

The backward compatibility between two Java EE 8- and Jakarta EE 9+ remote endpoints has to be enabled at the endpoint
that supports Jakarta EE 9+. To accomplish that, the Jakarta EE 9+ endpoint (a client or a server) is started with the system
property `org.wildfly.ee.namespace.interop` set to `true`. With this property enabled, a Jakarta EE 9+ server or client
becomes compatible with other Java EE 8- servers/clients, while still keeping the ability to communicate with other
Jakarta EE 9+ endpoints(as long as those endpoints have the same property enabled, see
<<communication-across-multiple-endpoints>>). We say that this particular server or client is running on *EE namespace
interoperable mode*.

Only Jakarta EE 9+ endpoints can run on EE namespace interoperable mode. For other endpoints, this property will be
ignored if set to `true`.

To implement that, we propose the following changes to the following libraries:


=== JBoss Marshalling

* Introduce new abstraction ClassNameTransformer that will allow to remap one java type to another java type.
* Provide hooks for that abstraction to allow renaming java types before/after marshalling/unmarshalling them.
* Provide default Java EE <-> Jakarta EE class name transformer implementation.

=== JBoss EJB Client

Since JBoss EJB protocol supports 'handshake' kind of messages it is possible to detect other side protocol version before exchanging messages. Because of this we propose to:

* Introduce new major version 4 of remote EJB protocol to indicate EJB client/server is supporting Jakarta EE 9+.
* Activate version 4 of EJB protocol if and only if JBoss EJB client/server is used in Jakarta EE9+ environment.
* Install Java EE <-> Jakarta EE class name transformer if and only if the client/server is running on EE namespace
interoperable mode, and the other side is using version 1 or 2 or 3 of the protocol.

=== WildFly Naming Client

Since WildFly NAMING protocol supports 'handshake' kind of messages it is possible to detect other side protocol version before exchanging messages. Because of this we propose to:

* Introduce new major version 3 of remote NAMING protocol to indicate NAMING client/server is supporting Jakarta EE 9+.
* Activate version 3 of NAMING protocol if and only if WildFly NAMING client/server is used in Jakarta EE9+ environment.
* Install Java EE <-> Jakarta EE class name transformer if and only if the client/server is running on EE namespace
interoperable mode, and the other side is using version 1 or 2 of the protocol.

=== WildFly Http Client

Since WildFly HTTP protocol doesn't support 'handshake' kind of messages it is not possible to detect other side
protocol version in advance. The version number is in the URL of the particular service provided by the server, and the request
is sent directly to that particular URL, without prior negotiation. Because of this we propose to:

* implement a protocol version handshake based on a HTTP header
* clients on standard mode will just send the request to the new protocol version, 2, bypassing the protocol version negotiation
* clients on EE namespace interoperability mode will send the request to protocol version 1 URL, with the header to negotiate
the definitive protocol version for that connection
* Install Java EE <-> Jakarta EE class name transformer if and only if using the protocol version 1

So, servers are always started making available the services on both versions 1 and 2. The difference between those
versions is solely that version 1 receives requests in the Java EE 8- namespace while version 2 receives requests in the Jakarta
EE 9+ namespace. For requests sent to version 1, the server applies the class name transformer to convert the classes to
Jakarta EE 9+ namespace. If the protocol version 1 request comes from a legacy client, the server just handles the request. If
the request comes from a Jakarta EE 9+ compatible client, there will be a header for protocol version negotiation. With this
header, the server will respond the client with the same header, indicating that the client can upgrade to version 2.

Let's see in more detail how the protocol version handshaking works between two Jakarta EE 9+ client and servers, where the client is running
on EE namespace interoperable mode:

* whenever the client side opens a connection using a new connection pool, the first request it sends via that connection is
forwarded to protocol version 1 URL. Also, this request contains the `x-wf-version: 2` HTTP header, and that first request is
marshalled with the Java EE 8- <-> Jakarta EE 9+ class transformer, transforming the EE api classes in the request to `javax` EE
namespace
* the server receives the request with a protocol version 1 HTTP handler. This handler verifies the request has the
`x-wf-version: 2` header, and adds the same header to the response. Also, as mentioned earlier, the class name transformer is
automatically enabled at the version 1 protocol handler. Furthermore, the header added to the response indicates that this
connection is a Jakarta EE 9+ connection at both ends, and the client is not supposed to transform the namespace of the EE
classes contained in the response data.
* from that point on, whenever the client uses the same connection, no transformation is done on its side, and all requests are
sent to the protocol version 2 URL, that performs no handshaking and no class file transformation at the server side.

Here is how the handshaking works when an EE namespace interoperable client sends a request to a Java EE 8- server:

* as in the previous case, the client side opens a new connection to a server, and the first request it sends at that connection
pool contains the `x-wf-version: 2` HTTP header. Also, that first request is marshalled
with the Java EE <-> Jakarta EE class transformer, porting the request from `jakarta` to `javax` EE namespace
* the Java EE 8- server receives the request in Java EE format and handles the request normally, ignoring the
`x-wf-version: 2` header.
* the client receives the server response and checks it does not contain the `x-wf-version` header. So, it enables the
Java EE <-> Jakarta EE class name transformer for that connection's lifetime, and marks that URI as a protocol version 1 at the
connection pool
* from that point on, whenever the client uses the same destiny, no extra header is added, all requests are sent to protocol version
1 path, and the class name transformer is always enabled, guaranteeing that the Jakarta EE 9+ classes are ported to Java EE 8-
namespace on every request, and transformed back on every response received from the server

The final handshake scenario is a Java EE 8- client sending a request to a EE namespace interoperable server:

* client sends the request to the server in the standard way, and the request  naturally can contain `javax` EE
namespace classes
* the server receives the request and verifies it does not contain the `x-wf-version` header. The server interprets
this as an indication that the client is Java EE 8-, and it enables the class name transformer for both reading the request
and writing the response back to the client.

If a Jakarta EE9+ server receives a request from an EE namespace interoperable client, even if the server is not on
interoperable mode it will be able to respond, because it will check the presence of the `x-wf-version: 2`
header. In this case, it will apply the class name transformation to the request on read, and it will add the
`x-wf-version: 2` header to the response on write. This allows the non-interoperable server to be able to serve
requests from interoperable clients.

=== Communication Across Multiple Endpoints
The following table summarizes the possible scenarios where a client can
communicate with a server remotely:

|===
|                                             |Java EE 8- client | Jakarta EE 9+ client | Jakarta EE 9+ namespace interoperable client
|Java EE 8- server                            | Yes              | No                   | Yes
|Jakarta EE 9+ server                         | Yes              | Yes                  | Yes
|Jakarta EE 9+ namespace interoperable server | Yes              | Yes                  | Yes
|===

Notice that all versions are interoperable, except the Jakarta EE 9+ client when sending requests to a legacy server. That
communication will not work unless it is on interoperable mode.

Regarding handling cases where a client is non-interoperable and sends a version 2 protocol request to a legacy server, the
we could make the client side smarter in the future, and enable EE interoperability mode. For HTTP based communication, we could
do so after receiving the 404 response from the server. For communication using remoting protocol, it could just allow switching to the latest
protocol in protocol handshaking when the connection is estabilished. Or we could print a warning indicating that the EE
namespace interoperability must be enabled when we find those situations, indicating to the final user that they need to enable
this mode so the client or server can establish proper communication with the remote endpoint.